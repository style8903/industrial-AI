# -*- coding: utf-8 -*-
"""3. dnn_cifar-10_classification_심야.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t8WbSj1lzcNPccnKAsjzW-q4_rDIjxoD

# DNN 모델을 이용한 Cifar-10 데이터셋 분류

## GPU 설정
"""

# 코드작성] GPU 상태 체크

!nvidia-smi

"""## step1. Cifar-10 datasets 준비"""

# import 
from tensorflow.keras.datasets import cifar10
import matplotlib.pyplot as plt

#  cifar10 데이터셋 load_data()

(train_images, train_labels), (test_images, test_labels) = cifar10.load_data()

#  train, test dataset 탐색 : shape

print(train_images.shape)
print(train_labels.shape)
print(test_images.shape)
print(test_labels.shape)

# [채팅창에~]
# train_images 는 몇 건인가요?
# train_images[0] 의 shape 은 어떻게 되나요?

train_labels

"""### 1-1 분류명을 직관적으로 출력"""



# train_labels 값 보기

class_names = ['airplane', 'automobile', 'bird', 'cat', 'deer',
               'dog', 'frog', 'horse', 'ship', 'truck']

# train_labels[3][0] 의 값은

# train_labels[3][0] 클래스 이름은?

# [질문] 맨 마지막 image는 무엇인가요?



# [질문] train_labels 10번째 class_names = index 9 ??

# 그래프로 표현하기

"""### 1-2 이미지 전처리
- 이미지의 픽셀값을 0과 1 사이로 스케일을 조정 - 정규화
- 먼저 float32 로 typecasting 후 정규화
"""

# train_images 의 datatype 출력

train_images = train_images.astype('float32') / 255
test_images = test_images.astype('float32') / 255

# train_images, test_images flatten ( samples, 1차원텐서 변경)

train_images = train_images.reshape(50000, 3072)
test_images = test_images.reshape(10000, 32*32*3)
train_images.shape
# [채팅창에~]
# flatten 후 train_imagesd의 shape 은?



"""### 1-3 레이블 인코딩
- 레이블을 범주형으로 인코딩
- to_categorical 사용
"""

# to_categorical import 
from tensorflow.keras.utils import to_categorical

# 레이블을 범주형으로 인코딩
train_labels = to_categorical(train_labels)
test_labels = to_categorical(test_labels)

# [채팅창] 첫번째 레이블을 출력해보기
print(train_labels[0])
print(test_labels[0])

"""## step2. DNN 모델 디자인"""

# models, layers import 
from tensorflow.keras import models, layers

# Sequential 모델 객체 생성
# input 생략
# hidden 1 (units=512, relu, input_shape=????)
# hidden 2 (units=256, relu)
# output layer (units=??, activation = ????)

# 모델 디자인 채팅창에~

model = models.Sequential()
model.add(layers.Dense(units=512, activation='relu', input_shape=(32 * 32 * 3,)))
model.add(layers.Dense(units=256, activation='relu'))
model.add(layers.Dense(units=10, activation='softmax'))  # (10) - 1

# model summary 보기

model.summary()

# 1 hidden layer parameter 갯수 
32*32*3*512+512
# 2 hidden layer 
512*256 + 256
# output layer
256*10+10

"""## step3. 훈련 준비하기 (컴파일 단계)
- optimizer : rmsprop
- loss (손실함수 ) : categorical_crossentropy
- metrics : accuracy
"""

# 채팅창에~

model.compile(optimizer='rmsprop',
              loss='categorical_crossentropy',
              metrics=['accuracy'])



"""## step4. 훈련하기 
- x : 입력 데이터
- y : 입력 라벨 값
- batch_size : 64
- epochs : 30
- validation_split : 0.2
"""

# 채팅창에 
# step 식  
50000 * 0.8 / 64

# fit 결과는 history 객체에 저장

history = model.fit(train_images, train_labels,
                    epochs=30, 
                    batch_size=64,  
                    validation_split=0.2)





"""## step5. 모델 평가하기"""

# test_images로 모델 평가하기 

test_loss, test_acc = model.evaluate(test_images, test_labels)

"""## Step6. 성능 시각화"""

# matplotlib import 
acc    = history.history['accuracy']
val_acc = history.history['val_accuracy']
loss = history.history['loss']
val_loss = history.history['val_loss']

epochs = range(1, len(acc) +1)

"""- Training and validation accuracy 그리기"""

plt.plot( acc, 'bo', label='Training acc')
plt.plot( val_acc, 'b', label='Validation acc')
plt.title('Training and validation accuracy')
plt.legend()

plt.show()



"""- Training and validation loss 그래프 그리기"""

# Training and validation loss 그래프 그리기
plt.plot(epochs, loss, 'bo', label='Training loss')
plt.plot(epochs, val_loss, 'b', label='Validation loss')
plt.title('Training and validation loss')
plt.legend()

plt.show()



"""## step7. 모델 사용하기"""

# numpy import 
import numpy as np

# test_image[0]로 예측하기

predict = model.predict(test_images[-1].reshape(1, 32 * 32 * 3))

print("predict probability:", predict)  
print('predict number:', np.argmax(predict))
print('predict name:', class_names[np.argmax(predict)])

# test_image[0] 이미지보기

plt.figure()
plt.imshow(test_images[-1].reshape(32,32,3))  # 이미지 show
plt.colorbar()
plt.show()

# 마지막 이미지..
# 예측값, 실제값